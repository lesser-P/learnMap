# 学习路线图

### 目的
这篇文档会对新人进行go语言学习的指引，跟随该文档，可以让你尽快进入实战！<br>
文档的格式是：提出知识点和问题，带着问题去学习，然后以能够回答问题作为学习的结束。<br>
需要注意的是，文档中的问题，都会在一对一会议中被当面提问。


### main和init函数
#### 问题
请使用main和init函数，在屏幕上输出：Hello World!，init负责输出Hello，main负责输出World！
#### 答案
输出 hello world，init先执行，多个init按声明顺序执行，最后执行main
执行顺序，先加载依赖包->常量->变量->init函数->main函数
### 变量和指针
#### 问题
Go语言中的变量传递是值拷贝还是指针拷贝？<br>
interface和any的区别是什么？
#### 答案
go中函数传参都是值拷贝，&取地址，*根据地址取值
值拷贝，指针类型保存的是指向值的一个指针变量

interface是定义接口的关键字，任何实现了interface接口的类型都成为这个接口的实现类型
type any = interface{}
而any是一个空接口的别名，把any作为参数作用是可以把任何类型的数据传入这个参数做处理（用来做反射？）


### 切片
#### 问题
切片的自动扩容原理是什么？<br>
使用for range遍历指针切片并修改值的时候，会有什么问题吗？
#### 答案
64位下一个容量为8字节，32位下一个容量为4字节
先判断当前容量翻倍是否小于预估量，如果小于预估量则扩容为预估量的大小，如果大于预估量则判断原本容量是否大于1024，如果大于1024则扩容1/4，如果小于1024则扩容一倍
确定了需要的容量大小后，进行申请内存，一般不会直接向操作系统申请而是向语言中的内存管理模块进行申请，内存管理模块会统一向操作系统申请一批内存分成常用的规格管理起来，当申请内存时会给我们足够大且接近申请规格的内存
这个时候会创建一个新数组把原来数组的元素移到这个数组中，然后再基础上添加新元素，再让这个切片指向这个新数组，这个时候修改原数组就不会影响到这个切片了。

修改了值之后再打印原来的切片，出来的数据依旧是未修改
### Hash
#### 问题
map的自动扩容原理是什么？<br>
map中的数据排序是确定的吗？
#### 答案
1 当map中的元素超过了当前容量的时候，Go语言会触发扩容操作。
2 go语言会分配一个更大的内存空间，新的内存空间大小通常是当前容量的两倍（按照不同的扩容策略做调整）
3 go语言会将原有的键值对重新哈希到新的内存地址，这涉及到计算每个键的新hash值，并将其放入哈希桶中
4 go语言会释放原有的内存空间，并更新map的相关属性，例如容量和哈希桶的指针
map的扩容涉及到重新计算哈希和内存分配，所以最好预先预估map的容量，来提高性能
map是无序的，map底层是一个哈希
如果要按照顺序获得元素可以先创建一个切片把键都保存在切片中，然后对这个切片进行排序，然后按照排序后的切片遍历获取map的值
### 函数
#### 问题
怎么理解函数在go语言中是一等公民？
#### 答案
这意味着函数享有和其他数据类型相同的地位和能力
可以作为参数传递、返回值、可赋值给变量和可以保存在数据结构中。这意味着Golang中的函数可以像其他值一样被操作和处理，从而可以实现一些高级特性，如函数闭包、高阶函数和函数式编程等。
### 面向对象编程
#### 问题
Go语言中的结构体可以实现继承吗？<br>
方法接收器使用指针还是值呢？
#### 答案
go中没有继承这个概念但是嵌套拥有一样的操作，把定义好的结构体当作属性加入到别的结构体那么这个结构体就实现了所继承的结构体的所有属性和方法,可以达到代码重用，并且可以扩展结构体的方法和属性，使代码更加灵活

值接收器
使用值接收器，方法内部对接收器的修改不会影响到原始值
可以接受值类型和指针类型，如果是指针，在方法内部会被转为值<br>
指针接收器
使用指针接收器时，方法内部对接收器的修改会影响到原始值
指针接收器可以接受指针类型和值，如果是值会被转成指针<br>
--转换这一部分是go自动进行的
选择原则：<br>
修改原始值则用指针接收器，当数据结构变大了使用指针接收器可以减少值接收器拷贝所带来的开销，在同一个类型中避免指针接收器和值接收器混用，提高代码的可读性和可维护性

安全性，需要保护原数据不变就使用值接收器

### defer
#### 问题
多个defer的执行顺序是怎么样的？
#### 答案
先进后出 栈
其中defer在return之后才执行,defer是延迟执行语句，常跟函数来关闭文件，资源链接等
defer后面可以跟着方法，有参函数，无参函数，方法和有参函数调用外部函数的参数就直接使用这个参数，无参函数调用外部函数参数会直接使用被修改过的参数 \
defer return 返回值的执行顺序
先执行return，当返回值是匿名变量时，会先创造一个临时变量来保存返回值，这个时候的返回值不是之前定的，这个时候defer修改的是之前定的变量，没有修改返回值 \
命名返回，执行return语句不会创建临时变量，而是使用之前就定义好的变量，所以defer能修改到返回值。 \
panic早于defer执行，defer搭配recover可以用来捕获panic，如果存在多个panic则捕获最后一个，后面的panic会覆盖掉前面的panic \
recover只能恢复同一个协程中的panic，不能跨协程捕获

### 包管理工具，go mod
#### 问题
怎么样可以把自己开发的包发布到git上被别人引用呢？
#### 答案
先创建github仓库，go mod init为仓库地址，然后提交代码，在github上创建release发布，使用go get 下载指定版本

### 协程
#### 问题
父协程结束后，子协程会立刻退出吗？<br>
怎么处理多协程的合作呢？<br>
GMP是什么？
#### 答案
1 如果这个父协程是主协程那么所有子协程都会立刻停止，如果不是那么父协程在结束后，子协程依旧会继续运行，父协程是用来开启其子协程的协程，子协程的运行状态并不受父协程的运行状态影响，但父协程可以做同步机制等待子协程完成 \
2 首先协程间通信使用channel，可以解决共享内存所产生的异常，用make关键词创建，用于不同协程间的通信和同步机制，先说没有缓冲区的channel起到阻塞的作用，struct{}作为通道的类型，更多起到的是信号的作用 \
mutex 并发控制机制，使用锁来对资源进行控制，保证在读写的情况下同一时间只有一个协程在对资源进行操作，lock和unlock互斥锁 \
Mutex结构体有两个属性 state和sema state用于表示锁的状态，seam用于实现锁的信号量，如果一个协程调用Lock方法，这个锁状态是未锁定那么协程会把锁的状态变为锁定并继续执行 \
如果已经加锁但有其他协程也调用了加锁操作，这个时候这个协程会进入阻塞状态，直到锁的状态变成未加锁，sema。
当一个协程调用unlock时锁的状态会变为未加锁，唤醒一个等待的goroutine并执行。
锁有两种模式正常模式和饥饿模式 \
当某个协程多次尝试获取锁但失败的情况下会发生
在饥饿模式下mutex进入自旋状态，自旋状态：不断对一个条件做判断不会释放对cpu的控制权直到条件完成继续执行剩下代码，此时若这个协程多次尝试获取锁但一直失败mutex会放慢自旋的频率，直到最后把这个协程重新放入等待队列
waitgroup
用于等待一组goroutine执行完成，Add添加等待信号量，Done释放等待信号量，Wait等待 \
这两种结构都有state和sema，一个判断是否加锁的状态和一个用于唤醒等待协程的信号量 \
GMP
G是协程，G需要绑定到P才能执行，在G的视角中P才是cpu \
P是调度器，是GMP模型的中枢做承上启下的作用，对于g而言p是其cpu，需要被p调度才能执行，对于m而言他是执行代理为他提供了必要条件，执行内容信息，p的数量决定了g最大并行数量，超过cpu核数时时无意义 \
M是线程的抽象会不和G绑定，也不会直接执行g而是和p调度器绑定，因为g和m没有绑死所以会出现跨m执行g的情况，全局有多个m和p，g最大并行数是p的数量，G的存放队列有全局队列，p的本地队列（优先），wating队列存放 \
取g的队列的优先级是先p的本地队列，然后是全局队列，最后是wait队列，好处是取本地队列时可以接近无锁化，减少全局锁的竞争
当一个p的队列为空时，会出发work-stealing机制，从其他队列中偷取一半的g填入自己的队列

### 通道 channel
#### 问题
消费者怎么知道生产者是否已经关闭通道了呢？
#### 答案
通过检查从通道返回的第二个参数是否是false来判断，如果是false则代表通道已经关闭没有更多的数据会被接收，
如果在做取数据的操作那这个时候不会阻塞而是返回这个通道类型的零值

### 部署
#### 问题
我在mac上开发的项目，如何部署到windows server上呢？
docker



想加载别的包的init但不调用其他包的方法
_ "awesomeProject/some" 使用这种方法导入包

any是golang1.18新引入的预定义标识符，可以用于代替interface{}
在泛型场景下，可将any用于类型限定，以表示任意类型。

详细了解interface和any
interface{}用于表示任何类型
interface 多态 泛型 
interface限定了一组方法签名，包含方法名入参返回值，本质上是一种类型，是指针类型
相同的调用方式产生不同的调用过程或调用结果这个操作叫做多态，如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值



Go语言中的结构体可以实现继承吗？go中继承的概念
不能实现继承，在go中应该说是组合
select
select是go中的控制结构，用于处理多个chan上等待数据并执行操作。当有多个通道准备就绪时select会随机选择一个进行执行
可以实现多路复用，限流控制，优雅退出，超时处理
```
bools := make(chan bool)
times := time.After(time.Second * 1)
select {
case data := <-bools:
fmt.Println(data)
case <-times:
fmt.Println("超时")
}
```
