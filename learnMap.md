# 学习路线图

### 目的
这篇文档会对新人进行go语言学习的指引，跟随该文档，可以让你尽快进入实战！<br>
文档的格式是：提出知识点和问题，带着问题去学习，然后以能够回答问题作为学习的结束。<br>
需要注意的是，文档中的问题，都会在一对一会议中被当面提问。


### main和init函数
#### 问题
请使用main和init函数，在屏幕上输出：Hello World!，init负责输出Hello，main负责输出World！
#### 答案
输出 hello world，init先执行，多个init按声明顺序执行，最后执行main
执行顺序，先加载依赖包->常量->变量->init函数->main函数
### 变量和指针
#### 问题
Go语言中的变量传递是值拷贝还是指针拷贝？<br>
interface和any的区别是什么？
#### 答案
go中函数传参都是值拷贝，&取地址，*根据地址取值
值拷贝，指针类型保存的是指向值的一个指针变量

interface是定义接口的关键字，任何实现了interface接口的类型都成为这个接口的实现类型
type any = interface{}
而any是一个空接口的别名，把any作为参数作用是可以把任何类型的数据传入这个参数做处理（用来做反射？）


### 切片
#### 问题
切片的自动扩容原理是什么？<br>
使用for range遍历指针切片并修改值的时候，会有什么问题吗？
#### 答案
64位下一个容量为8字节，32位下一个容量为4字节
先判断当前容量翻倍是否小于预估量，如果小于预估量则扩容为预估量的大小，如果大于预估量则判断原本容量是否大于1024，如果大于1024则扩容1/4，如果小于1024则扩容一倍
确定了需要的容量大小后，进行申请内存，一般不会直接向操作系统申请而是向语言中的内存管理模块进行申请，内存管理模块会统一向操作系统申请一批内存分成常用的规格管理起来，当申请内存时会给我们足够大且接近申请规格的内存
这个时候会创建一个新数组把原来数组的元素移到这个数组中，然后再基础上添加新元素，再让这个切片指向这个新数组，这个时候修改原数组就不会影响到这个切片了。

修改了值之后再打印原来的切片，出来的数据依旧是未修改
### Hash
#### 问题
map的自动扩容原理是什么？<br>
map中的数据排序是确定的吗？
#### 答案
1 当map中的元素超过了当前容量的时候，Go语言会触发扩容操作。
2 go语言会分配一个更大的内存空间，新的内存空间大小通常是当前容量的两倍（按照不同的扩容策略做调整）
3 go语言会将原有的键值对重新哈希到新的内存地址，这涉及到计算每个键的新hash值，并将其放入哈希桶中
4 go语言会释放原有的内存空间，并更新map的相关属性，例如容量和哈希桶的指针
map的扩容涉及到重新计算哈希和内存分配，所以最好预先预估map的容量，来提高性能
map是无序的，map底层是一个哈希
如果要按照顺序获得元素可以先创建一个切片把键都保存在切片中，然后对这个切片进行排序，然后按照排序后的切片遍历获取map的值
### 函数
#### 问题
怎么理解函数在go语言中是一等公民？
#### 答案
这意味着函数享有和其他数据类型相同的地位和能力
可以作为参数传递、返回值、可赋值给变量和可以保存在数据结构中。这意味着Golang中的函数可以像其他值一样被操作和处理，从而可以实现一些高级特性，如函数闭包、高阶函数和函数式编程等。
### 面向对象编程
#### 问题
Go语言中的结构体可以实现继承吗？<br>
方法接收器使用指针还是值呢？
#### 答案
go中没有继承这个概念但是嵌套拥有一样的操作，把定义好的结构体当作属性加入到别的结构体那么这个结构体就实现了所继承的结构体的所有属性和方法,可以达到代码重用，并且可以扩展结构体的方法和属性，使代码更加灵活

值接收器
使用值接收器，方法内部对接收器的修改不会影响到原始值
可以接受值类型和指针类型，如果是指针，在方法内部会被转为值<br>
指针接收器
使用指针接收器时，方法内部对接收器的修改会影响到原始值
指针接收器可以接受指针类型和值，如果是值会被转成指针<br>
--转换这一部分是go自动进行的
选择原则：<br>
修改原始值则用指针接收器，当数据结构变大了使用指针接收器可以减少值接收器拷贝所带来的开销，在同一个类型中避免指针接收器和值接收器混用，提高代码的可读性和可维护性

安全性，需要保护原数据不变就使用值接收器

### defer
#### 问题
多个defer的执行顺序是怎么样的？
#### 答案
先进后出 栈
其中defer在return之后才执行,defer是延迟执行语句，常跟函数来关闭文件，资源链接等
defer后面可以跟着方法，有参函数，无参函数，方法和有参函数调用外部函数的参数就直接使用这个参数，无参函数调用外部函数参数会直接使用被修改过的参数 \
defer return 返回值的执行顺序
先执行return，当返回值是匿名变量时，会先创造一个临时变量来保存返回值，这个时候的返回值不是之前定的，这个时候defer修改的是之前定的变量，没有修改返回值 \
命名返回，执行return语句不会创建临时变量，而是使用之前就定义好的变量，所以defer能修改到返回值。 \
panic早于defer执行，defer搭配recover可以用来捕获panic，如果存在多个panic则捕获最后一个，后面的panic会覆盖掉前面的panic \
recover只能恢复同一个协程中的panic，不能跨协程捕获

### 包管理工具，go mod
#### 问题w
怎么样可以把自己开发的包发布到git上被别人引用呢？
#### 答案

### 协程
#### 问题
父协程结束后，子协程会立刻退出吗？<br>
怎么处理多协程的合作呢？<br>
GMP是什么？

### 通道 channel
#### 问题
消费者怎么知道生产者是否已经关闭通道了呢？

### 部署
#### 问题
我在mac上开发的项目，如何部署到windows server上呢？



想加载别的包的init但不调用其他包的方法
_ "awesomeProject/some" 使用这种方法导入包

any是golang1.18新引入的预定义标识符，可以用于代替interface{}
在泛型场景下，可将any用于类型限定，以表示任意类型。

详细了解interface和any
interface{}用于表示任何类型
interface 多态 泛型 
interface限定了一组方法签名，包含方法名入参返回值，本质上是一种类型，是指针类型
相同的调用方式产生不同的调用过程或调用结果这个操作叫做多态，如果一个类型实现了某个接口，所有使用这个接口的地方，都可以支持这种类型的值
